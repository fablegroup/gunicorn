import queue
from collections import deque
from collections.abc import Callable
from concurrent.futures import Future, ThreadPoolExecutor
from selectors import BaseSelector
from signal import Signals
from socket import socket
from types import FrameType
from typing import Type, TypeAlias

from _typeshed import Incomplete
from typing_extensions import Self

from gunicorn.config import Config
from gunicorn.glogging import Logger
from gunicorn.http.message import Message

from .base import Worker

_t_peer: TypeAlias = tuple[str, int] | str | bytes
_future_sig = Callable[[socket], tuple[bool, socket]]

class TConn:
    cfg: Incomplete
    sock: Incomplete
    client: Incomplete
    server: Incomplete
    timeout: Incomplete
    parser: Incomplete
    initialized: bool
    def __init__(
        self, cfg: Config, sock: socket, client: _t_peer, server: _t_peer
    ) -> None: ...
    def init(self) -> None: ...
    def set_keepalive_timeout(self) -> None: ...
    def is_initialized(self) -> bool: ...
    def close(self) -> None: ...

class PollableMethodQueue:
    fds: list[int]
    method_queue: queue.SimpleQueue | None

    def init(self) -> None: ...
    def close(self) -> None: ...
    def get_fd(self) -> int: ...
    def defer(self, callback: Incomplete, *args: Incomplete) -> None: ...
    def run_callbacks(self, max_callbacks_at_a_time: int = 10) -> None: ...

class ThreadWorker(Worker):
    worker_connections: Incomplete
    max_keepalived: int
    tpool: ThreadPoolExecutor
    poller: BaseSelector
    futures: deque[Future[_future_sig]]
    _keep: deque[socket]
    nr_conns: int
    @classmethod
    def check_config(cls: type[Self], cfg: Config, log: Logger) -> None: ...
    def init_process(self) -> None: ...
    def get_thread_pool(self) -> ThreadPoolExecutor: ...
    alive: bool
    def set_accept_enabled(self, enabled: bool) -> None: ...
    def handle_quit(self, sig: Signals, frame: FrameType | None) -> None: ...
    def accept(self, listener: socket) -> None: ...
    def on_client_socket_readable(self, conn: socket, client: _t_peer) -> None: ...
    def murder_keepalived(self) -> None: ...
    def is_parent_alive(self) -> bool: ...
    def wait_for_and_dispatch_events(self, timeout: int) -> None: ...
    def run(self) -> None: ...
    def finish_request(self, conn: socket, fs: Future[_future_sig]) -> None: ...
    def handle(self, conn: socket) -> tuple[bool, socket]: ...
    def handle_request(self, req: Message, conn: socket) -> bool: ...
